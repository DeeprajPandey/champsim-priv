/*
 * Implements a stream prefetcher: if a cache miss, prefetches A+1 to A+k blocks
 * into one of l stream buffers (pick lru) and prefetches the block with missed addr.
 * If A+1 is accessed at any point, A+k+1 is added to the buffer.
 *
 * 28 March, 2019
 * Deepraj Pandey
 */

#include <queue>
#include <vector>
#include <assert.h>
#include "cache.h"

#define BUFFER_DEPTH 4
#define NUM_BUFFERS 8

using namespace std;

vector< queue<uint64_t> > all_buffers;

void CACHE::l1d_prefetcher_initialize() 
{
	// initialise 8 fifo streams
	for (uint8_t i=0; i<NUM_BUFFERS; i++) {
		all_buffers.push_back(queue<uint64_t>());
	}
	assert(all_buffers.size() == NUM_BUFFERS);
}

void CACHE::l1d_prefetcher_operate(uint64_t base_addr, uint64_t ip, uint8_t cache_hit, uint8_t type)
{
	if (type != LOAD)
		return;

	uint64_t block_num = base_addr >> LOG2_BLOCK_SIZE;

	// we care only about the misses
	if (cache_hit == 0) {
		// check if the block is in any of the stream buffers
		uint8_t index = -1;

		for (index=0; index<NUM_BUFFERS; index++) {
	        if (all_buffers[index].front() == block_num)
	            break;
    	}
	}
	else {
	}

	uint64_t pf_addr = ((base_addr>>LOG2_BLOCK_SIZE)+1) << LOG2_BLOCK_SIZE;

	DP (if (warmup_complete[cpu]) {
    cout << "[" << NAME << "] " << __func__ << hex << " base_cl: " << (base_addr>>LOG2_BLOCK_SIZE);
    cout << " pf_cl: " << (pf_addr>>LOG2_BLOCK_SIZE) << " ip: " << ip << " cache_hit: " << +cache_hit << " type: " << +type << endl; });

    prefetch_line(ip, base_addr, pf_addr, FILL_L1, 0);
}

void CACHE::l1d_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{

}

void CACHE::l1d_prefetcher_final_stats()
{
	cout << "CPU " << cpu << " L1D stream prefetcher final stats" << endl;
}
